import {
  busDeviceInfos,
  controllerInfos,
  type ControllerInfo
} from "~/components/controllerInfo";
import {
  isI2cBus,
  isShiftRegisterDevice,
  isSpiBus,
  isWS2812,
  type AnyBus,
  type I2cBus,
  type I2cDevice,
  type Keyboard,
  type SpiBus,
  type SpiDevice
} from "~/typedef";

export type PinctrlOutput = {
  dts: string;
  defconfig: string;
};

type InternalPinctrlOutput = {
  dts: string;
  kconfig: string[];
  conf?: string; // nothing implemented yet
}

export function createShieldPinctrlFile(keyboard: Keyboard, partIndex: number): PinctrlOutput | null {
  // Add more in the future as needed
  return createNrf52840PinctrlFile(keyboard, partIndex);
  // return createRp2040PinctrlFile(part);
}

function createNrf52840PinctrlFile(keyboard: Keyboard, partIndex: number): PinctrlOutput | null {
  const part = keyboard.parts[partIndex];
  // loop over all buses and check for devices, return early if none found
  if (Math.max(0, ...part.buses.map(bus => bus.devices.length)) === 0) {
    return null;
  }

  const controllerInfo = controllerInfos[part.controller];

  const shieldName = keyboard.parts.length > 1 ? `${keyboard.shield}_${part.name}` : keyboard.shield;
  let dts = `
/**
 * Generated by Shield Wizard for ZMK
 * Applies to shield "${shieldName}" with board "${controllerInfo.board}" only
 */

`;

  const kconfig: string[] = [];

  for (const bus of part.buses) {
    if (bus.devices.length === 0) {
      // unused bus, skip
      continue;
    }

    dts += `
//
// ======== ${bus.name} ========
//
`;

    // if this is SPI bus, make sure device type `niceview` is sorted first
    // make sure nice!view always has reg = <0>
    // sort in place
    if (isSpiBus(bus)) {
      bus.devices.sort((a, b) => (a.type === 'niceview' ? -1 : 0) - (b.type === 'niceview' ? -1 : 0));
    }

    dts += nrf52840PinctrlNode(controllerInfo, bus);

    const deviceResult = attachDevices(controllerInfo, bus);
    dts += deviceResult.dts;
    // defconfig += deviceResult.defconfig + "\n";
    kconfig.push(...deviceResult.kconfig);
  };

  // if defconfig has anything other tha empty lines, return it
  // else return null for defconfig
  let defconfig = '';
  if (kconfig.length > 0) {
    defconfig = `
# ---------------------
# Kconfig for shield "${shieldName}" with board "${controllerInfo.board}"
# ---------------------
if ${controllerInfo.boardKconfig} && SHIELD_${shieldName.toUpperCase()}

${Array.from(new Set(kconfig)).join('\n')}

endif
`;

  }

  return { dts, defconfig };
}

function nrf52840PinctrlNode(controllerInfo: ControllerInfo, bus: AnyBus): string {
  const pselsArray: string[] = [];
  const pselsComments: string[] = [];

  if (isI2cBus(bus)) {
    if (bus.sda) {
      pselsArray.push(`<NRF_PSEL(TWIM_SDA, ${controllerInfo.pins[bus.sda].pinctrlRef})>`);
      pselsComments.push(`SDA on ${controllerInfo.pins[bus.sda].displayName}`);
    }
    if (bus.scl) {
      pselsArray.push(`<NRF_PSEL(TWIM_SCL, ${controllerInfo.pins[bus.scl].pinctrlRef})>`);
      pselsComments.push(`SCL on ${controllerInfo.pins[bus.scl].displayName}`);
    }
  } else if (isSpiBus(bus)) {
    if (bus.sck) {
      pselsArray.push(`<NRF_PSEL(SPIM_SCK, ${controllerInfo.pins[bus.sck].pinctrlRef})>`);
      pselsComments.push(`SCK on ${controllerInfo.pins[bus.sck].displayName}`);
    }
    if (bus.mosi) {
      pselsArray.push(`<NRF_PSEL(SPIM_MOSI, ${controllerInfo.pins[bus.mosi].pinctrlRef})>`);
      pselsComments.push(`MOSI on ${controllerInfo.pins[bus.mosi].displayName}`);
    }
    if (bus.miso) {
      pselsArray.push(`<NRF_PSEL(SPIM_MISO, ${controllerInfo.pins[bus.miso].pinctrlRef})>`);
      pselsComments.push(`MISO on ${controllerInfo.pins[bus.miso].displayName}`);
    }
  }

  const psels = pselsArray.join(",\n                    ");

  let content = `
// pin control for ${bus.name}
${pselsComments.map(c => `// - ${c}`).join("\n")}
&pinctrl {
    /* configuration for ${bus.name} device, default state */
    ${bus.name}_default: ${bus.name}_default {
        group1 {
            psels = ${psels};
        };
    };
    /* configuration for ${bus.name} device, sleep state */
    ${bus.name}_sleep: ${bus.name}_sleep {
        group1 {
            psels = ${psels};
            low-power-enable;
        };
    };
};
&${bus.name} {
  compatible = "${bus.type === "i2c" ? "nordic,nrf-twim" : "nordic,nrf-spim"}";
  status = "okay";
  pinctrl-0 = <&${bus.name}_default>;
  pinctrl-1 = <&${bus.name}_sleep>;
  pinctrl-names = "default", "sleep";
${bus.type === "i2c" ? `  clock-frequency = <I2C_BITRATE_FAST>;\n` : ""
    }\};
`;

  return content;
}

function attachDevices(controllerInfo: ControllerInfo, bus: AnyBus): InternalPinctrlOutput {
  let kconfig: string[] = [];
  let dts = `
// devices on ${bus.name}
`;

  if (isI2cBus(bus)) {
    kconfig.push(`
config I2C
    default y
`);
    bus.devices.forEach((device) => {
      const builder = i2cDevices[device.type];
      if (builder) {
        const output = builder(bus as I2cBus, device as I2cDevice);
        dts += output.dts;
        kconfig.push(...output.kconfig);
      } else {
        throw new Error(`Unsupported I2C device type for pinctrl generation: ${device.type}`);
      }
    });
  } else if (isSpiBus(bus)) {
    kconfig.push(`
config SPI
    default y
`);

    // either all devices have a cs pin, or none have
    const allHaveCs = bus.devices.every(device => !!(device.cs));
    if (allHaveCs) {
      const cspins = bus.devices.map((d) => {
        return `<${controllerInfo.pins[d.cs!].dtsRef} ${busDeviceInfos[d.type].csActiveHigh ? 'GPIO_ACTIVE_HIGH' : 'GPIO_ACTIVE_LOW'}>`;
      }).join(', ');
      dts += `
// CS pins for devices on ${bus.name}
&${bus.name} \{
    cs-gpios = ${cspins};
\};
`;
    } else {
      dts += `
// CS pins not defined for at least one device on ${bus.name}, skipping CS pin configuration
`
    }

    bus.devices.forEach((device, index) => {
      const builder = spiDevices[device.type];
      if (builder) {
        const output = builder(bus as SpiBus, device as SpiDevice, index);
        dts += output.dts;
        kconfig.push(...output.kconfig);
      } else {
        throw new Error(`Unsupported SPI device type for pinctrl generation: ${device.type}`);
      }
    });
  } else {
    throw new Error(`Unsupported bus type for pinctrl generation: ${(bus as any)?.type}`);
  }
  return { dts, kconfig };
}

type I2cDeviceBuilderFunc = (bus: I2cBus, device: I2cDevice) => InternalPinctrlOutput;
const i2cDevices: Record<I2cDevice["type"], I2cDeviceBuilderFunc> = {
  ssd1306: (bus, device) => {
    const addressHex = device.add.toString(16).padStart(2, '0');
    const dts = `
&${bus.name} {
    oled: ssd1306@${addressHex} {
        compatible = "solomon,ssd1306fb";
        reg = <0x${addressHex}>;
        width = <${device.width}>;
        height = <${device.height}>;

        segment-offset = <0>;
        page-offset = <0>;
        display-offset = <0>;
        multiplex-ratio = <31>;
        prechargep = <0x22>;
        segment-remap;
        com-invdir;
        com-sequential;
        inversion-on;
    };
};
/ {
    chosen {
        zephyr,display = &oled;
    };
};
`;
    return {
      dts,
      kconfig: [
        `
config ZMK_DISPLAY
    default y

if ZMK_DISPLAY

config I2C
    default y

config SSD1306
    default y

endif # ZMK_DISPLAY

if LVGL

config LV_Z_VDB_SIZE
    default 64

config LV_DPI_DEF
    default 148

config LV_Z_BITS_PER_PIXEL
    default 1

choice LV_COLOR_DEPTH
    default LV_COLOR_DEPTH_1
endchoice

endif # LVGL
`
      ]
    };
  },
};

type SpiDeviceBuilderFunc = (bus: SpiBus, device: SpiDevice, index: number) => InternalPinctrlOutput;
const spiDevices: Record<SpiDevice["type"], SpiDeviceBuilderFunc> = {
  niceview: (bus, _device, _index) => {
    const dts = `
// Label ${bus.name} as nice_view_spi,
// The actual device node is defined in the \`nice_view\` shield.
nice_view_spi: &${bus.name} { };
`;
    return { dts, kconfig: [] };
  },
  ws2812: (bus, device, index): InternalPinctrlOutput => {
    if (!isWS2812(device)) return { dts: '', kconfig: [] };
    const dts = `
#include <dt-bindings/led/led.h>
&${bus.name} {
    led_strip: ws2812@${index} {
        compatible = "worldsemi,ws2812-spi";
        reg = <${index}>;
        spi-max-frequency = <4000000>;

        chain-length = <${device.length}>;
        spi-one-frame = <0x70>;
        spi-zero-frame = <0x40>;
        color-mapping = <LED_COLOR_ID_GREEN
                         LED_COLOR_ID_RED
                         LED_COLOR_ID_BLUE>;
    };
};
/ {
    chosen {
        zmk,underglow = &led_strip;
    };
};
`;
    return {
      dts,
      kconfig: [
        `
config WS2812_STRIP
    default y
`,
      ]
    };
  },
  "74hc595": (bus, device, index): InternalPinctrlOutput => {
    if (!isShiftRegisterDevice(device)) return { dts: '', kconfig: [] };

    const dts = `
&${bus.name} {
    shifter: 595@${index} {
        compatible = "zmk,gpio-595";
        reg = <${index}>;
        status = "okay";
        gpio-controller;
        spi-max-frequency = <200000>;
        #gpio-cells = <2>;
        ngpios = <${device.ngpios}>;
    };
};
`;
    return { dts, kconfig: [] };
  },
};
