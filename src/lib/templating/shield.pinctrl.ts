import { controllerInfos, getBusDeviceMetadata, type ControllerInfo } from "~/components/controllerInfo";
import type { AnyBus, I2cDevice, Keyboard, SpiDevice } from "~/typedef";
import { isI2cBus, isInputDevice, isPmw3610, isShiftRegisterDevice, isSpiBus, isWS2812 } from "~/typehelper";
import { inputDeviceNodeName } from "./utils";

export type PinctrlOutput = {
  dts: string;
  defconfig: string;
};

type InternalPinctrlOutput = {
  dts: string;
  kconfig: string[];
  conf?: string; // nothing implemented yet
}

type DeviceBuilderArgs<TDevice> = {
  busName: string;
  device: TDevice;
  controllerInfo: ControllerInfo;
  index?: number;
  dtsNodeName?: string;
};

export function createShieldPinctrlFile(keyboard: Keyboard, partIndex: number): PinctrlOutput | null {
  const controller = controllerInfos[keyboard.parts[partIndex].controller];

  switch (controller.soc) {
    case "nrf52840":
      return createNrf52840PinctrlFile(keyboard, partIndex);
    case "rp2040":
      return createRp2040PinctrlFile(keyboard, partIndex);
    default:
      return null;
  }
}

function createRp2040PinctrlFile(keyboard: Keyboard, partIndex: number): PinctrlOutput | null {
  const part = keyboard.parts[partIndex];

  // loop over all buses and check for devices, return early if none found
  if (Math.max(0, ...part.buses.map(bus => bus.devices.length)) === 0) {
    return null;
  }

  const controllerInfo = controllerInfos[part.controller];
  const shieldName = keyboard.parts.length > 1 ? `${keyboard.shield}_${part.name}` : keyboard.shield;

  let dts = `
/**
 * Generated by Shield Wizard for ZMK
 * Applies to shield "${shieldName}" with board "${controllerInfo.board}" only
 */

#include <dt-bindings/pinctrl/rpi-pico-rp2040-pinctrl.h>

`;

  const kconfig: string[] = [];

  let pointingIdx = 0;
  const nextInputBaseName = () => `${part.name}${pointingIdx++}`;

  for (const bus of part.buses) {
    if (bus.devices.length === 0) {
      continue;
    }

    dts += `
//
// ======== ${bus.name} ========
//
`;

    if (isSpiBus(bus)) {
      bus.devices.sort((a, b) => (a.type === "niceview" ? -1 : 0) - (b.type === "niceview" ? -1 : 0));
    }

    dts += rp2040PinctrlNode(controllerInfo, bus);

    const deviceResult = attachDevices(controllerInfo, bus, nextInputBaseName);
    dts += deviceResult.dts;
    kconfig.push(...deviceResult.kconfig);
  }

  let defconfig = "";
  if (kconfig.length > 0) {
    defconfig = `
# ---------------------
# Kconfig for shield "${shieldName}" with board "${controllerInfo.board}"
# ---------------------
if ${controllerInfo.boardKconfig} && SHIELD_${shieldName.toUpperCase()}

${Array.from(new Set(kconfig)).join("\n")}

endif
`;

  }

  return { dts, defconfig };
}

function createNrf52840PinctrlFile(keyboard: Keyboard, partIndex: number): PinctrlOutput | null {
  const part = keyboard.parts[partIndex];
  // loop over all buses and check for devices, return early if none found
  if (Math.max(0, ...part.buses.map(bus => bus.devices.length)) === 0) {
    return null;
  }

  const controllerInfo = controllerInfos[part.controller];

  const shieldName = keyboard.parts.length > 1 ? `${keyboard.shield}_${part.name}` : keyboard.shield;
  let dts = `
/**
 * Generated by Shield Wizard for ZMK
 * Applies to shield "${shieldName}" with board "${controllerInfo.board}" only
 */

`;

  const kconfig: string[] = [];

  let pointingIdx = 0;
  const nextInputBaseName = () => `${part.name}${pointingIdx++}`;

  for (const bus of part.buses) {
    if (bus.devices.length === 0) {
      // unused bus, skip
      continue;
    }

    dts += `
//
// ======== ${bus.name} ========
//
`;

    // if this is SPI bus, make sure device type `niceview` is sorted first
    // make sure nice!view always has reg = <0>
    // sort in place
    if (isSpiBus(bus)) {
      bus.devices.sort((a, b) => (a.type === 'niceview' ? -1 : 0) - (b.type === 'niceview' ? -1 : 0));
    }

    dts += nrf52840PinctrlNode(controllerInfo, bus);

    const deviceResult = attachDevices(controllerInfo, bus, nextInputBaseName);
    dts += deviceResult.dts;
    // defconfig += deviceResult.defconfig + "\n";
    kconfig.push(...deviceResult.kconfig);
  };

  // if defconfig has anything other tha empty lines, return it
  // else return null for defconfig
  let defconfig = '';
  if (kconfig.length > 0) {
    defconfig = `
# ---------------------
# Kconfig for shield "${shieldName}" with board "${controllerInfo.board}"
# ---------------------
if ${controllerInfo.boardKconfig} && SHIELD_${shieldName.toUpperCase()}

${Array.from(new Set(kconfig)).join('\n')}

endif
`;

  }

  return { dts, defconfig };
}

function nrf52840PinctrlNode(controllerInfo: ControllerInfo, bus: AnyBus): string {
  const pselsArray: string[] = [];
  const pselsComments: string[] = [];

  if (isI2cBus(bus)) {
    if (bus.sda) {
      pselsArray.push(`<NRF_PSEL(TWIM_SDA, ${controllerInfo.pins[bus.sda].pinctrlRef})>`);
      pselsComments.push(`SDA on ${controllerInfo.pins[bus.sda].displayName}`);
    }
    if (bus.scl) {
      pselsArray.push(`<NRF_PSEL(TWIM_SCL, ${controllerInfo.pins[bus.scl].pinctrlRef})>`);
      pselsComments.push(`SCL on ${controllerInfo.pins[bus.scl].displayName}`);
    }
  } else if (isSpiBus(bus)) {
    if (bus.sck) {
      pselsArray.push(`<NRF_PSEL(SPIM_SCK, ${controllerInfo.pins[bus.sck].pinctrlRef})>`);
      pselsComments.push(`SCK on ${controllerInfo.pins[bus.sck].displayName}`);
    }
    if (bus.mosi) {
      pselsArray.push(`<NRF_PSEL(SPIM_MOSI, ${controllerInfo.pins[bus.mosi].pinctrlRef})>`);
      pselsComments.push(`MOSI on ${controllerInfo.pins[bus.mosi].displayName}`);
    }
    if (bus.miso) {
      pselsArray.push(`<NRF_PSEL(SPIM_MISO, ${controllerInfo.pins[bus.miso].pinctrlRef})>`);
      pselsComments.push(`MISO on ${controllerInfo.pins[bus.miso].displayName}`);
    }
  }

  const psels = pselsArray.join(",\n                    ");

  let content = `
// pin control for ${bus.name}
${pselsComments.map(c => `// - ${c}`).join("\n")}
&pinctrl {
    /* configuration for ${bus.name} device, default state */
    ${bus.name}_default: ${bus.name}_default {
        group1 {
            psels = ${psels};
        };
    };
    /* configuration for ${bus.name} device, sleep state */
    ${bus.name}_sleep: ${bus.name}_sleep {
        group1 {
            psels = ${psels};
            low-power-enable;
        };
    };
};
&${bus.name} {
  compatible = "${bus.type === "i2c" ? "nordic,nrf-twim" : "nordic,nrf-spim"}";
  status = "okay";
  pinctrl-0 = <&${bus.name}_default>;
  pinctrl-1 = <&${bus.name}_sleep>;
  pinctrl-names = "default", "sleep";
${bus.type === "i2c" ? `  clock-frequency = <I2C_BITRATE_FAST>;\n` : ""
    }\};
`;

  return content;
}

function rp2040PinctrlNode(controllerInfo: ControllerInfo, bus: AnyBus): string {
  const pinmuxEntries: string[] = [];
  const pinComments: string[] = [];
  const rxEntries: string[] = [];

  if (isI2cBus(bus)) {
    if (bus.sda) {
      const pin = controllerInfo.pins[bus.sda];
      pinmuxEntries.push(`<${bus.name.toUpperCase()}_SDA_P${pin.pinctrlRef}>`);
      pinComments.push(`SDA on ${pin.displayName}`);
    }
    if (bus.scl) {
      const pin = controllerInfo.pins[bus.scl];
      pinmuxEntries.push(`<${bus.name.toUpperCase()}_SCL_P${pin.pinctrlRef}>`);
      pinComments.push(`SCL on ${pin.displayName}`);
    }
  } else if (isSpiBus(bus)) {
    if (bus.sck) {
      const pin = controllerInfo.pins[bus.sck];
      pinmuxEntries.push(`<${bus.name.toUpperCase()}_SCK_P${pin.pinctrlRef}>`);
      pinComments.push(`SCK on ${pin.displayName}`);
    }
    if (bus.mosi) {
      const pin = controllerInfo.pins[bus.mosi];
      pinmuxEntries.push(`<${bus.name.toUpperCase()}_TX_P${pin.pinctrlRef}>`);
      pinComments.push(`MOSI on ${pin.displayName}`);
    }
    if (bus.miso) {
      const pin = controllerInfo.pins[bus.miso];
      rxEntries.push(`<${bus.name.toUpperCase()}_RX_P${pin.pinctrlRef}>`);
      pinComments.push(`MISO on ${pin.displayName}`);
    }
  }

  const pinmux = pinmuxEntries.join(", ");
  const rxPinmux = rxEntries.join(", ");

  if (!pinmux && !rxPinmux) {
    throw new Error(`No pinmux entries generated for ${bus.name}`);
  }

  const groups: string[] = [];

  if (pinmux) {
    groups.push(`        group1 {
            pinmux = ${pinmux};
${isI2cBus(bus) ? "            input-enable;\n            input-schmitt-enable;\n" : ""}        };
`);
  }

  if (rxPinmux) {
    groups.push(`        ${pinmux ? "group2" : "group1"} {
            pinmux = ${rxPinmux};
            input-enable;
        };
`);
  }

  let content = `
// pin control for ${bus.name}
${pinComments.map(c => `// ${c}`).join("\n")}
&pinctrl {
    ${bus.name}_default: ${bus.name}_default {
${groups.join("")}    };
};
&${bus.name} {
    status = "okay";
    pinctrl-0 = <&${bus.name}_default>;
    pinctrl-names = "default";
${isI2cBus(bus) ? "    clock-frequency = <I2C_BITRATE_FAST>;\n" : ""}};
`;

  return content;
}

/**
 * Attach devices on the given bus.
 * This is shared between all supported MCUs.
 * @param controllerInfo Controller info for the part
 * @param bus The bus to attach devices to
 * @param getNextInputBaseName Function to get the next node name for input devices
 * @returns DTS and Kconfig snippets
 */
function attachDevices(controllerInfo: ControllerInfo, bus: AnyBus, getNextInputBaseName: () => string): InternalPinctrlOutput {
  let kconfig: string[] = [];
  let dts = `
// devices on ${bus.name}
`;

  if (isI2cBus(bus)) {
    kconfig.push(`
config I2C
    default y
`);
    bus.devices.forEach((device) => {
      const builder = i2cDevices[device.type];
      if (builder) {
        const dtsNodeName = (isInputDevice(device) && getNextInputBaseName) ? getNextInputBaseName() : undefined;
        const output = builder({
          busName: bus.name,
          device: device as I2cDevice,
          controllerInfo,
          dtsNodeName,
        });
        dts += output.dts;
        kconfig.push(...output.kconfig);
      } else {
        throw new Error(`Unsupported I2C device type for pinctrl generation: ${device.type}`);
      }
    });
  } else if (isSpiBus(bus)) {
    kconfig.push(`
config SPI
    default y
`);

    const devicesWithCs = bus.devices.filter((device) => {
      const meta = getBusDeviceMetadata(device.type);
      return 'cs' in meta.props && meta.props.cs && meta.props.cs.widget === "pin";
    });

    const allHaveCs = devicesWithCs.every((device) => 'cs' in device && device.cs);

    if (devicesWithCs.length > 0 && allHaveCs) {
      const cspins = devicesWithCs.map((d) => {
        const csPin = 'cs' in d && d.cs ? d.cs : ''; // should always have value because we checked above
        const pinRef = controllerInfo.pins[csPin].dtsRef;
        const gpioFlag = getBusDeviceMetadata(d.type).csActiveHigh ? 'GPIO_ACTIVE_HIGH' : 'GPIO_ACTIVE_LOW';
        return `<${pinRef} ${gpioFlag}>`;
      });

      dts += `
// CS pins for devices on ${bus.name}
&${bus.name} \{
    cs-gpios = ${cspins.join(', ')};
\};
`;
    } else if (devicesWithCs.length > 0) {
      dts += `
// CS pins not defined for at least one device on ${bus.name}, skipping CS pin configuration
`
    }

    bus.devices.forEach((device, index) => {
      const builder = spiDevices[device.type];
      if (builder) {
        const dtsNodeName = (isInputDevice(device) && getNextInputBaseName) ? getNextInputBaseName() : undefined;
        const output = builder({
          busName: bus.name,
          device: device as SpiDevice,
          index,
          controllerInfo,
          dtsNodeName,
        });
        dts += output.dts;
        kconfig.push(...output.kconfig);
      } else {
        throw new Error(`Unsupported SPI device type for pinctrl generation: ${device.type}`);
      }
    });
  } else {
    throw new Error(`Unsupported bus type for pinctrl generation: ${(bus as any)?.type}`);
  }
  return { dts, kconfig };
}
type I2cDeviceBuilderFunc = (arg: DeviceBuilderArgs<I2cDevice>) => InternalPinctrlOutput;

const i2cDevices: Record<I2cDevice["type"], I2cDeviceBuilderFunc> = {
  ssd1306: ({ busName, device }) => {
    if (device.type !== "ssd1306") return { dts: '', kconfig: [] };

    const addressHex = device.add.toString(16).padStart(2, '0');

    const dts = `
&${busName} {
    oled: ssd1306@${addressHex} {
        compatible = "solomon,ssd1306fb";
        reg = <0x${addressHex}>;
        width = <${device.width}>;
        height = <${device.height}>;

        segment-offset = <0>;
        page-offset = <0>;
        display-offset = <0>;
        multiplex-ratio = <31>;
        prechargep = <0x22>;
        segment-remap;
        com-invdir;
        com-sequential;
        inversion-on;
    };
};
/ {
    chosen {
        zephyr,display = &oled;
    };
};
`;
    return {
      dts,
      kconfig: [
        `
config ZMK_DISPLAY
    default y

if ZMK_DISPLAY

config I2C
    default y

config SSD1306
    default y

endif # ZMK_DISPLAY

if LVGL

config LV_Z_VDB_SIZE
    default 64

config LV_DPI_DEF
    default 148

config LV_Z_BITS_PER_PIXEL
    default 1

choice LV_COLOR_DEPTH
    default LV_COLOR_DEPTH_1
endchoice

endif # LVGL
`
      ]
    };
  },
  pinnacle_i2c: ({ busName, device, controllerInfo, dtsNodeName }): InternalPinctrlOutput => {
    if (device.type !== "pinnacle_i2c") return { dts: '', kconfig: [] };

    const addressHex = device.add.toString(16).padStart(2, '0');

    const name = inputDeviceNodeName(dtsNodeName || `pinnacle_spi`);
    const rotate90 = device.rotate90 ? `\n        rotate-90;` : '';
    const invx = device.invertx ? `\n        x-invert;` : '';
    const invy = device.inverty ? `\n        y-invert;` : '';
    const sleep = device.sleep ? `\n        sleep;` : '';
    const noSecondaryTap = device.noSecondaryTap ? `\n        no-secondary-tap;` : '';
    const noTaps = device.noTaps ? `\n        no-taps;` : '';

    const dts = `
&${busName} {
    ${name}: ${name}@${addressHex} {
        status = "okay";
        compatible = "cirque,pinnacle";
        reg = <0x${addressHex}>;
        dr-gpios = <${controllerInfo.pins[device.dr || '']?.dtsRef} (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;${rotate90}${invx}${invy}${sleep}${noSecondaryTap}${noTaps}
        sensitivity = "${device.sensitivity}";
    };
};
`;
    return { dts, kconfig: [] };
  }
};

type SpiDeviceBuilderFunc = (arg: DeviceBuilderArgs<SpiDevice> & { index: number }) => InternalPinctrlOutput;

const spiDevices: Record<SpiDevice["type"], SpiDeviceBuilderFunc> = {
  niceview: ({ busName }) => {
    const dts = `
// Label ${busName} as nice_view_spi,
// The actual device node is defined in the \`nice_view\` shield.
nice_view_spi: &${busName} { };
`;
    return { dts, kconfig: [] };
  },
  ws2812: ({ busName, device, index }): InternalPinctrlOutput => {
    if (!isWS2812(device) || index === undefined) return { dts: '', kconfig: [] };
    const dts = `
#include <dt-bindings/led/led.h>
&${busName} {
    led_strip: ws2812@${index} {
        compatible = "worldsemi,ws2812-spi";
        reg = <${index}>;
        spi-max-frequency = <4000000>;

        chain-length = <${device.length}>;
        spi-one-frame = <0x70>;
        spi-zero-frame = <0x40>;
        color-mapping = <LED_COLOR_ID_GREEN
                         LED_COLOR_ID_RED
                         LED_COLOR_ID_BLUE>;
    };
};
/ {
    chosen {
        zmk,underglow = &led_strip;
    };
};
`;
    return {
      dts,
      kconfig: [
        `
config WS2812_STRIP
    default y
`,
      ]
    };
  },
  "74hc595": ({ busName, device, index }): InternalPinctrlOutput => {
    if (!isShiftRegisterDevice(device) || index === undefined) return { dts: '', kconfig: [] };

    const dts = `
&${busName} {
    shifter: 595@${index} {
        compatible = "zmk,gpio-595";
        reg = <${index}>;
        status = "okay";
        gpio-controller;
        spi-max-frequency = <200000>;
        #gpio-cells = <2>;
        ngpios = <${device.ngpios}>;
    };
};
`;
    return { dts, kconfig: [] };
  },
  pmw3610: ({ busName, device, index, controllerInfo, dtsNodeName }): InternalPinctrlOutput => {
    if (!isPmw3610(device) || index === undefined) return { dts: '', kconfig: [] };

    const name = inputDeviceNodeName(dtsNodeName || `pmw3610`);
    const swap = device.swapxy ? `\n        swap-xy;` : '';
    const invx = device.invertx ? `\n        invert-x;` : '';
    const invy = device.inverty ? `\n        invert-y;` : '';

    const dts = `
#include <zephyr/dt-bindings/input/input-event-codes.h>

&${busName} {
    ${name}: ${name}@${index} {
        status = "okay";
        compatible = "pixart,pmw3610";
        reg = <${index}>;
        spi-max-frequency = <2000000>;
        evt-type = <INPUT_EV_REL>;
        x-input-code = <INPUT_REL_X>;
        y-input-code = <INPUT_REL_Y>;
        irq-gpios = <${controllerInfo.pins[device.irq || '']?.dtsRef} (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
        cpi = <${device.cpi}>;${swap}${invx}${invy}
    };
};
`;
    return {
      dts,
      kconfig: [
        `
config PMW3610
    default y
`
      ]
    };
  },
  paw3395: ({ busName, device, index, controllerInfo, dtsNodeName }): InternalPinctrlOutput => {
    if (device.type !== "paw3395" || index === undefined) return { dts: '', kconfig: [] };

    const name = inputDeviceNodeName(dtsNodeName || `paw3395`);
    const swap = device.swapxy ? `\n        swap-xy;` : '';
    const invx = device.invertx ? `\n        invert-x;` : '';
    const invy = device.inverty ? `\n        invert-y;` : '';

    const dts = `
#include <zephyr/dt-bindings/input/input-event-codes.h>

&${busName} {
    ${name}: ${name}@${index} {
        status = "okay";
        compatible = "pixart,paw3395";
        reg = <${index}>;
        spi-max-frequency = <4000000>;
        evt-type = <INPUT_EV_REL>;
        x-input-code = <INPUT_REL_X>;
        y-input-code = <INPUT_REL_Y>;
        irq-gpios = <${controllerInfo.pins[device.irq || '']?.dtsRef} (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;
        cpi = <${device.cpi}>;${swap}${invx}${invy}
    };
};
`;
    return {
      dts,
      kconfig: [
        `
config PAW3395
    default y
`
      ]
    };
  },
  pinnacle_spi: ({ busName, device, index, controllerInfo, dtsNodeName }): InternalPinctrlOutput => {
    if (device.type !== "pinnacle_spi" || index === undefined) return { dts: '', kconfig: [] };

    const name = inputDeviceNodeName(dtsNodeName || `pinnacle_spi`);
    const rotate90 = device.rotate90 ? `\n        rotate-90;` : '';
    const invx = device.invertx ? `\n        x-invert;` : '';
    const invy = device.inverty ? `\n        y-invert;` : '';
    const sleep = device.sleep ? `\n        sleep;` : '';
    const noSecondaryTap = device.noSecondaryTap ? `\n        no-secondary-tap;` : '';
    const noTaps = device.noTaps ? `\n        no-taps;` : '';

    const dts = `
&${busName} {
    ${name}: ${name}@${index} {
        status = "okay";
        compatible = "cirque,pinnacle";
        reg = <${index}>;
        spi-max-frequency = <2000000>;
        dr-gpios = <${controllerInfo.pins[device.dr || '']?.dtsRef} (GPIO_ACTIVE_LOW | GPIO_PULL_UP)>;${rotate90}${invx}${invy}${sleep}${noSecondaryTap}${noTaps}
        sensitivity = "${device.sensitivity}";
    };
};
`;
    return { dts, kconfig: [] };
  },
};
