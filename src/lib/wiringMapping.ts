import type { AnyBus, Controller, Key, KeyboardPart, PinSelection, ShiftRegisterDevice, SingleKeyWiring, WiringType } from "../typedef";

// Copy and map wiring between two parts based on key layout and wiring configuration
// Allow for transformations like flipping vertically/horizontally to make wiring split parts easier

// Note: this entire file was fully generated by LLM and I have reviewed exactly 0 lines of it.
// It seems to behave reasonably well from me playing around, so good enough.

export type WiringTransform = "none" | "flip-vert" | "flip-horiz" | "flip-both";

interface PartKey {
  id: string;
  row: number;
  col: number;
  wiring?: SingleKeyWiring;
}

interface NormalizedKey extends PartKey {
  normRow: number;
  normCol: number;
}

export interface WiringCopyParams {
  layout: Key[];
  sourcePartIndex: number;
  targetPartIndex: number;
  sourcePart: KeyboardPart;
  targetPart: KeyboardPart;
  transform: WiringTransform;
}

export interface WiringCopyResult {
  controller: Controller;
  wiring: WiringType;
  pins: PinSelection;
  keys: Record<string, SingleKeyWiring>;
  mapped: number;
  totalTargets: number;
  buses: AnyBus[];
}

type BoundingBox = {
  minRow: number;
  maxRow: number;
  minCol: number;
  maxCol: number;
};

function toPartKeys(layout: Key[], partIndex: number, part: KeyboardPart): PartKey[] {
  return layout
    .filter(k => k.part === partIndex)
    .map(k => ({
      id: k.id,
      row: k.row,
      col: k.col,
      wiring: part.keys?.[k.id],
    }));
}

function computeBoundingBox(keys: PartKey[]): BoundingBox {
  if (keys.length === 0) {
    return { minRow: 0, maxRow: 0, minCol: 0, maxCol: 0 };
  }

  return keys.reduce<BoundingBox>((acc, k) => ({
    minRow: Math.min(acc.minRow, k.row),
    maxRow: Math.max(acc.maxRow, k.row),
    minCol: Math.min(acc.minCol, k.col),
    maxCol: Math.max(acc.maxCol, k.col),
  }), {
    minRow: keys[0].row,
    maxRow: keys[0].row,
    minCol: keys[0].col,
    maxCol: keys[0].col,
  });
}

function transformKeys(keys: PartKey[], transform: WiringTransform): PartKey[] {
  if (transform === "none") return keys.map(k => ({ ...k }));

  const box = computeBoundingBox(keys);
  const flipHoriz = transform === "flip-horiz" || transform === "flip-both";
  const flipVert = transform === "flip-vert" || transform === "flip-both";

  return keys.map(k => ({
    ...k,
    row: flipVert ? box.minRow + (box.maxRow - k.row) : k.row,
    col: flipHoriz ? box.minCol + (box.maxCol - k.col) : k.col,
  }));
}

function normalizeKeys(keys: PartKey[]): NormalizedKey[] {
  if (keys.length === 0) return [];

  const box = computeBoundingBox(keys);
  return keys.map(k => ({
    ...k,
    normRow: k.row - box.minRow,
    normCol: k.col - box.minCol,
  }));
}

function pairKeys(source: PartKey[], target: PartKey[]): Map<string, PartKey> {
  const normalizedSource = normalizeKeys(source);
  const normalizedTarget = normalizeKeys(target);

  const usedSource = new Set<string>();
  const mapping = new Map<string, PartKey>();

  // Exact coordinate matches first
  for (const targetKey of normalizedTarget) {
    const match = normalizedSource.find(s => !usedSource.has(s.id) && s.normRow === targetKey.normRow && s.normCol === targetKey.normCol);
    if (match) {
      usedSource.add(match.id);
      mapping.set(targetKey.id, match);
    }
  }

  // Best-effort pairing for remaining keys
  const remainingTargets = normalizedTarget.filter(t => !mapping.has(t.id)).sort((a, b) => (a.normRow - b.normRow) || (a.normCol - b.normCol));
  const remainingSources = normalizedSource.filter(s => !usedSource.has(s.id)).sort((a, b) => (a.normRow - b.normRow) || (a.normCol - b.normCol));

  const pairCount = Math.min(remainingTargets.length, remainingSources.length);
  for (let i = 0; i < pairCount; i++) {
    const src = remainingSources[i];
    const tgt = remainingTargets[i];
    usedSource.add(src.id);
    mapping.set(tgt.id, src);
  }

  return mapping;
}

export function copyWiringBetweenParts(params: WiringCopyParams): WiringCopyResult {
  const { layout, sourcePartIndex, targetPartIndex, sourcePart, targetPart, transform } = params;

  const sourceKeys = transformKeys(toPartKeys(layout, sourcePartIndex, sourcePart), transform);
  const targetKeys = toPartKeys(layout, targetPartIndex, targetPart);

  const mapping = pairKeys(sourceKeys, targetKeys);

  const resultKeys: Record<string, SingleKeyWiring> = {};
  let mapped = 0;

  for (const target of targetKeys) {
    const match = mapping.get(target.id);
    if (!match || !match.wiring) continue;

    const wiring: SingleKeyWiring = {};
    if (match.wiring.input) wiring.input = match.wiring.input;
    if (match.wiring.output) wiring.output = match.wiring.output;

    if (wiring.input || wiring.output) {
      resultKeys[target.id] = wiring;
      mapped += 1;
    }
  }

  // Filter out bus pin usage; only carry over input/output pins
  const resultPins: PinSelection = {};
  for (const [pinId, mode] of Object.entries(sourcePart.pins || {})) {
    if (mode === "input" || mode === "output") {
      resultPins[pinId] = mode;
    }
  }

  // Carry over shift register only; drop other bus devices and bus pin usage.
  const busPinsToMark = new Set<string>();
  const resultBuses: AnyBus[] = (sourcePart.buses || []).map((bus): AnyBus => {
    if (bus.type === "spi") {
      const shifter = (bus.devices || []).find((d): d is ShiftRegisterDevice => d.type === "74hc595");
      const devices = shifter ? [{ ...shifter }] : [];
      const mosi = shifter ? bus.mosi : undefined;
      const miso = shifter ? bus.miso : undefined;
      const sck = shifter ? bus.sck : undefined;

      if (shifter) {
        if (mosi) busPinsToMark.add(mosi);
        if (miso) busPinsToMark.add(miso);
        if (sck) busPinsToMark.add(sck);
        if (shifter.cs) busPinsToMark.add(shifter.cs);
      }

      return {
        type: "spi",
        name: bus.name,
        mosi,
        miso,
        sck,
        devices,
      } satisfies AnyBus;
    }

    return {
      type: "i2c",
      name: bus.name,
      sda: undefined,
      scl: undefined,
      devices: [],
    } satisfies AnyBus;
  });

  // Mark shift-register bus pins as bus usage
  for (const pinId of busPinsToMark) {
    resultPins[pinId] = "bus";
  }

  return {
    controller: sourcePart.controller,
    wiring: sourcePart.wiring,
    pins: resultPins,
    keys: resultKeys,
    mapped,
    totalTargets: targetKeys.length,
    buses: resultBuses,
  };
}
