import type { KeyboardPart, Key, SingleKeyWiring, PinSelection, Controller, WiringType } from "../typedef";

// Note: this entire file was fully generated by LLM and I have reviewed exactly 0 lines of it.
// It seems to behave reasonably well from me playing around, so good enough.

export type WiringTransform = "none" | "flip-vert" | "flip-horiz" | "flip-both";

interface PartKey {
  id: string;
  row: number;
  col: number;
  wiring?: SingleKeyWiring;
}

interface NormalizedKey extends PartKey {
  normRow: number;
  normCol: number;
}

export interface WiringCopyParams {
  layout: Key[];
  sourcePartIndex: number;
  targetPartIndex: number;
  sourcePart: KeyboardPart;
  targetPart: KeyboardPart;
  transform: WiringTransform;
}

export interface WiringCopyResult {
  controller: Controller;
  wiring: WiringType;
  pins: PinSelection;
  keys: Record<string, SingleKeyWiring>;
  mapped: number;
  totalTargets: number;
}

type BoundingBox = {
  minRow: number;
  maxRow: number;
  minCol: number;
  maxCol: number;
};

function toPartKeys(layout: Key[], partIndex: number, part: KeyboardPart): PartKey[] {
  return layout
    .filter(k => k.part === partIndex)
    .map(k => ({
      id: k.id,
      row: k.row,
      col: k.col,
      wiring: part.keys?.[k.id],
    }));
}

function computeBoundingBox(keys: PartKey[]): BoundingBox {
  if (keys.length === 0) {
    return { minRow: 0, maxRow: 0, minCol: 0, maxCol: 0 };
  }

  return keys.reduce<BoundingBox>((acc, k) => ({
    minRow: Math.min(acc.minRow, k.row),
    maxRow: Math.max(acc.maxRow, k.row),
    minCol: Math.min(acc.minCol, k.col),
    maxCol: Math.max(acc.maxCol, k.col),
  }), {
    minRow: keys[0].row,
    maxRow: keys[0].row,
    minCol: keys[0].col,
    maxCol: keys[0].col,
  });
}

function transformKeys(keys: PartKey[], transform: WiringTransform): PartKey[] {
  if (transform === "none") return keys.map(k => ({ ...k }));

  const box = computeBoundingBox(keys);
  const flipHoriz = transform === "flip-horiz" || transform === "flip-both";
  const flipVert = transform === "flip-vert" || transform === "flip-both";

  return keys.map(k => ({
    ...k,
    row: flipVert ? box.minRow + (box.maxRow - k.row) : k.row,
    col: flipHoriz ? box.minCol + (box.maxCol - k.col) : k.col,
  }));
}

function normalizeKeys(keys: PartKey[]): NormalizedKey[] {
  if (keys.length === 0) return [];

  const box = computeBoundingBox(keys);
  return keys.map(k => ({
    ...k,
    normRow: k.row - box.minRow,
    normCol: k.col - box.minCol,
  }));
}

function pairKeys(source: PartKey[], target: PartKey[]): Map<string, PartKey> {
  const normalizedSource = normalizeKeys(source);
  const normalizedTarget = normalizeKeys(target);

  const usedSource = new Set<string>();
  const mapping = new Map<string, PartKey>();

  // Exact coordinate matches first
  for (const targetKey of normalizedTarget) {
    const match = normalizedSource.find(s => !usedSource.has(s.id) && s.normRow === targetKey.normRow && s.normCol === targetKey.normCol);
    if (match) {
      usedSource.add(match.id);
      mapping.set(targetKey.id, match);
    }
  }

  // Best-effort pairing for remaining keys
  const remainingTargets = normalizedTarget.filter(t => !mapping.has(t.id)).sort((a, b) => (a.normRow - b.normRow) || (a.normCol - b.normCol));
  const remainingSources = normalizedSource.filter(s => !usedSource.has(s.id)).sort((a, b) => (a.normRow - b.normRow) || (a.normCol - b.normCol));

  const pairCount = Math.min(remainingTargets.length, remainingSources.length);
  for (let i = 0; i < pairCount; i++) {
    const src = remainingSources[i];
    const tgt = remainingTargets[i];
    usedSource.add(src.id);
    mapping.set(tgt.id, src);
  }

  return mapping;
}

export function copyWiringBetweenParts(params: WiringCopyParams): WiringCopyResult {
  const { layout, sourcePartIndex, targetPartIndex, sourcePart, targetPart, transform } = params;

  const sourceKeys = transformKeys(toPartKeys(layout, sourcePartIndex, sourcePart), transform);
  const targetKeys = toPartKeys(layout, targetPartIndex, targetPart);

  const mapping = pairKeys(sourceKeys, targetKeys);

  const resultKeys: Record<string, SingleKeyWiring> = {};
  let mapped = 0;

  for (const target of targetKeys) {
    const match = mapping.get(target.id);
    if (!match || !match.wiring) continue;

    const wiring: SingleKeyWiring = {};
    if (match.wiring.input) wiring.input = match.wiring.input;
    if (match.wiring.output) wiring.output = match.wiring.output;

    if (wiring.input || wiring.output) {
      resultKeys[target.id] = wiring;
      mapped += 1;
    }
  }

  return {
    controller: sourcePart.controller,
    wiring: sourcePart.wiring,
    pins: { ...sourcePart.pins },
    keys: resultKeys,
    mapped,
    totalTargets: targetKeys.length,
  };
}
